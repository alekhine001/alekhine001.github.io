### C++ ###

```c++
#include <iostream>
#include <cstring>
using namespace std;

class student { 
private: 
	string name; 
	int age; 
	string hobby;
public: 
	void ShowInfo(); 
	void SetInfo(string _name, int _age, string _hobby);
	void Study();
	void Sleep();
}; 

void student::ShowInfo(){ 
	cout << "이름: " << name << ", 나이: " << age << ", 취미: " << hobby << endl;
}

void student::SetInfo(string _name, int _age, string _hobby){
	name = _name; age = _age; hobby = _hobby; 
} 
void student::Study(){
	cout << "공부!" << endl;
} 
void student::Sleep(){
	cout << "잠!" << endl;
} 
```

객체지향의 핵심은 실세계의 물체의 행동(behavior,function)과 상태(member,state)를 실체화시키는데 있습니다.

c++의 클래스는 c의 구조체에서 확장되어 멤버변수와 더불어 함수, 그리고 다른 클래스 또한 포함시킬 수 있습니다.

추가적으로 클래스는 기본 접근 제한(PUBLIC, PROTECTED, PRIVATE)의 차이가 있습니다.

그중 PROTECTED는 일종의 캡슐화로 외부로부터 보호되지만, 자신의 하위계층에는 공개하는 특징을 가지고 있습니다. 상속에서 상위 클래스의 PRIVATE는 하위클래스에서조차 접근할 수 없는것을 PROTECTD를 이용하면 접근을 할 수 있습니다. 따라서 외부에는 공개하기 싫지만, 자식 클래스에서 사용 할 수 있도록 하는 방법이 PROTECTED입니다.

은닉화: 유지보수

캡슐화: 순서대로 하려면, 도중에 순차가 꼬이면 안되는경우 캡슐화를 통해 실수가 없도록 한다.

클래스 안이 멤버변수가 클래스가 될 수 있다.

힙은 스택의 '생성-소멸 규칙'을 따르지 않고 프로그래머가 직접 메모리를 관리 할 수 있다.

자신의 인스턴스를 가르키는 포인터를 명시할때 this 키워드를 사용하는데, 없어도 별 상관 없지만, 가독성을 위해 웬만하면 붙인다.

### 상속 ###
```c++
class Person{
private:
    string name_;
    int age_;
public:
    Person(const string& name, int age); // 기초 클래스 생성자의 선언
    void ShowPersonInfo();
};

Person::Person(const string& name, int age) // 기초 클래스 생성자의 정의
{
    name_ = name;
    age_ = age;
}

student::student(int sid, const string &name, int age): person(&name,age){
  student_id=sid;
}
```
위와같이 person이란 클래스를 student가 상속받는다고 할때, 프로그램은 먼저 기초클래스인 person 클래스의 생성자를 호출합니다. 이때 기초클래스 생성자는 상속받은 멤버변수의 초기화를 진행합니다.

그리고서 파생클래스의 생성자가 호출됩니다.

반대로 파생클래스의 수명이 다하면, 파생클래스의 소멸자가 먼저 호출되고, 그 후 기초클래스의 소멸자가 호출됩니다.

가상함수: 상속받은 함수들이 같은 함수를 호출해도 다른 인삿말을 하도록 한다 -> virtual을 이용

  가상함수는 일단 기본적인 행동양식은 제공하되, 원한다면 파생클래스에서 동작을 재정의 할 수 있도록 한다. Polymorphism을 구현하여 객체지향 언어를 더 사람의 세상에 가깝도록 합니다. 가상함수의 장점은 부모 클래스의 포인터로 자손 객체를 담은 뒤, 가상함수를 호출할때, 하나의 포인터 형식으로 무수히 많은 파생 객체들의 주소값을 담을 수 있고, 단 하나의 인터페이스만 갖고도 수많은 파생 객체들의 서로 다른 행동을 표현 할 수 있게 되는것입니다. 분명 포인터는 하나인데, 그저 서로 다른 객체의 주소값을 가르키는 것만으로도 결과가 달라집니다.

상속 요약: 

1) 상위 계통 특징은 하위 계통에도 있다.

2) 부모 클래스의 포인터엔 자손 객체의 주소가 담길 수 있다.

3) 부모 클래스의 포인터로 가상함수를 호출하면 자손 객체의 재정의된 함수가 호출된다.

const의 사용
1. 전역 볌위에서 상수를 만들때

2. ~~반환형에서 const~~

3. 포인터의 상수화

    1) 포인터가 가리키는 대상을 바꿀 수 없도록 만든다.
  
    2) 포인터가 가리키는 대상 자체를 조작 할 수 없도록 만든다.
  
  ```c++
  const int* a
  int * const a
  const int * const a
  ```
  함수의 매개변수로 포인터를 받을때 유용합니다. 혹시 원본값을 조작하면 안되는 경우 const 선언을 하면 코드의 안정성을 확보하는데 도움이 됩니다.

4. 멤버변수에서의 const

객체 생성시에 const 키워드를 사용하면 그 객체는 상수취급되어 초기화된 데이터 외의 다른 데이터로 변경 할 수 없습니다.

```c++
const Point pt1(10, 20);
pt1.SetX(30);
pt1.SetY(40);
```

5. 멤버 함수에서의 const

  멤버함수에서 const를 사용함은 이 함수 내에선 this 클래스의 멤버를 절대 건드리지 않겠다는것을 의미함으로써, 가독성을 높이는 역활을 합니다. 즉 '읽기전용' 함수로 만듭니다.

  또한 const 키워드가 붙은 함수는 const 키워드가 붙지 않은 함수를 호출 할 수 없습니다. 간접적으로 객체내 멤버변수를 조작 할 수 있는 위험이 있기 때문입니다.
  
  참고로 생성자와 소멸자는 항상 객체의 데이터를 변경시키기에, const를 사용할 수 없습니다.

```c++
class Point {
private:
  int x_, y_;
public:
  Point();
  Point(int x, int y);
  inline int GetX() const {
    return x_;
  }
  inline int GetY() const {
    return y_;
  }
}
```
